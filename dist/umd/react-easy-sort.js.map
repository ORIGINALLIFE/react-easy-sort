{"version":3,"file":"react-easy-sort.js","sources":["../../src/helpers.ts","../../src/hooks.ts","../../src/index.tsx"],"sourcesContent":["import { Point } from './types'\n\n/**\n * This function check if a given point is inside of the items rect.\n * If it's not inside any rect, it will return the index of the closest rect\n */\nexport const findItemIndexAtPosition = (\n  { x, y }: Point,\n  itemsRect: DOMRect[],\n  { fallbackToClosest = false } = {}\n): number => {\n  let smallestDistance = 10000\n  let smallestDistanceIndex = -1\n  for (let index = 0; index < itemsRect.length; index += 1) {\n    const rect = itemsRect[index]\n    // if it's inside the rect, we return the current index directly\n    if (x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom) {\n      return index\n    }\n    if (fallbackToClosest) {\n      // otherwise we compute the distance and update the smallest distance index if needed\n      const itemCenterX = (rect.left + rect.right) / 2\n      const itemCenterY = (rect.top + rect.bottom) / 2\n\n      const distance = Math.sqrt(Math.pow(x - itemCenterX, 2) + Math.pow(y - itemCenterY, 2)) // ** 2 operator is not supported on IE11\n      if (distance < smallestDistance) {\n        smallestDistance = distance\n        smallestDistanceIndex = index\n      }\n    }\n  }\n  return smallestDistanceIndex\n}\n","import React from 'react'\n\nimport { Point } from './types'\n\nconst getMousePoint = (e: MouseEvent | React.MouseEvent): Point => ({\n  x: Number(e.clientX),\n  y: Number(e.clientY),\n})\n\nconst getTouchPoint = (touch: Touch | React.Touch): Point => ({\n  x: Number(touch.clientX),\n  y: Number(touch.clientY),\n})\n\nconst getPointInContainer = (point: Point, containerTopLeft: Point): Point => {\n  return {\n    x: point.x - containerTopLeft.x,\n    y: point.y - containerTopLeft.y,\n  }\n}\n\nconst preventDefault = (event: Event) => {\n  event.preventDefault()\n}\n\nconst disableContextMenu = () => {\n  window.addEventListener('contextmenu', preventDefault, { capture: true, passive: false })\n}\n\nconst enableContextMenu = () => {\n  window.removeEventListener('contextmenu', preventDefault)\n}\n\nexport type OnStartArgs = { point: Point; pointInWindow: Point }\nexport type OnMoveArgs = { point: Point; pointInWindow: Point }\n\ntype UseDragProps = {\n  onStart?: (args: OnStartArgs) => void\n  onMove?: (args: OnMoveArgs) => void\n  onEnd?: () => void\n  containerRef: React.MutableRefObject<HTMLElement | null>\n  knobs?: HTMLElement[]\n}\n\nexport const useDrag = ({ onStart, onMove, onEnd, containerRef, knobs }: UseDragProps) => {\n  // contains the top-left coordinates of the container in the window. Set on drag start and used in drag move\n  const containerPositionRef = React.useRef<Point>({ x: 0, y: 0 })\n  // on touch devices, we only start the drag gesture after pressing the item 200ms.\n  // this ref contains the timer id to be able to cancel it\n  const handleTouchStartTimerRef = React.useRef<number | undefined>(undefined)\n  // on non-touch device, we don't call onStart on mouse down but on the first mouse move\n  // we do this to let the user clicks on clickable element inside the container\n  // this means that the drag gesture actually starts on the fist move\n  const isFirstMoveRef = React.useRef(false)\n  // see https://twitter.com/ValentinHervieu/status/1324407814970920968\n  // we do this so that the parent doesn't have to use `useCallback()` for these callbacks\n  const callbacksRef = React.useRef({ onStart, onMove, onEnd })\n\n  // instead of relying on hacks to know if the device is a touch device or not,\n  // we track this using an onTouchStart listener on the document. (see https://codeburst.io/the-only-way-to-detect-touch-with-javascript-7791a3346685)\n  const [isTouchDevice, setTouchDevice] = React.useState(false)\n\n  React.useEffect(() => {\n    callbacksRef.current = { onStart, onMove, onEnd }\n  }, [onStart, onMove, onEnd])\n\n  const cancelTouchStart = () => {\n    if (handleTouchStartTimerRef.current) {\n      window.clearTimeout(handleTouchStartTimerRef.current)\n    }\n  }\n\n  const saveContainerPosition = React.useCallback(() => {\n    if (containerRef.current) {\n      const bounds = containerRef.current.getBoundingClientRect()\n      containerPositionRef.current = { x: bounds.left, y: bounds.top }\n    }\n  }, [containerRef])\n\n  const onDrag = React.useCallback((pointInWindow: Point) => {\n    const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n    if (callbacksRef.current.onMove) {\n      callbacksRef.current.onMove({ pointInWindow, point })\n    }\n  }, [])\n\n  const onMouseMove = React.useCallback(\n    (e: MouseEvent) => {\n      // if this is the first move, we trigger the onStart logic\n      if (isFirstMoveRef.current) {\n        isFirstMoveRef.current = false\n        const pointInWindow = getMousePoint(e)\n        const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n        if (callbacksRef.current.onStart) {\n          callbacksRef.current.onStart({ point, pointInWindow })\n        }\n      }\n      // otherwise, we do the normal move logic\n      else {\n        onDrag(getMousePoint(e))\n      }\n    },\n    [onDrag]\n  )\n\n  const onTouchMove = React.useCallback(\n    (e: TouchEvent) => {\n      if (e.cancelable) {\n        // Prevent the whole page from scrolling\n        e.preventDefault()\n        onDrag(getTouchPoint(e.touches[0]))\n      } else {\n        // if the event is not cancelable, it means the browser is currently scrolling\n        // which cannot be interrupted. Thus we cancel the drag gesture.\n        document.removeEventListener('touchmove', onTouchMove)\n        if (callbacksRef.current.onEnd) {\n          callbacksRef.current.onEnd()\n        }\n      }\n    },\n    [onDrag]\n  )\n\n  const onMouseUp = React.useCallback(() => {\n    isFirstMoveRef.current = false\n    document.removeEventListener('mousemove', onMouseMove)\n    document.removeEventListener('mouseup', onMouseUp)\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd()\n    }\n  }, [onMouseMove])\n\n  const onTouchEnd = React.useCallback(() => {\n    document.removeEventListener('touchmove', onTouchMove)\n    document.removeEventListener('touchend', onTouchEnd)\n    enableContextMenu()\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd()\n    }\n  }, [onTouchMove])\n\n  const onMouseDown = React.useCallback(\n    (e: React.MouseEvent<HTMLElement, MouseEvent>) => {\n      if (e.button !== 0) {\n        // we don't want to handle clicks other than left ones\n        return\n      }\n\n      if (knobs?.length && !knobs.find((knob) => knob.contains(e.target as Node))) {\n        return\n      }\n\n      document.addEventListener('mousemove', onMouseMove)\n      document.addEventListener('mouseup', onMouseUp)\n\n      saveContainerPosition()\n\n      // mark the next move as being the first one\n      isFirstMoveRef.current = true\n    },\n    [onMouseMove, onMouseUp, saveContainerPosition, knobs]\n  )\n\n  const handleTouchStart = React.useCallback(\n    (point: Point, pointInWindow: Point) => {\n      document.addEventListener('touchmove', onTouchMove, { capture: false, passive: false })\n      document.addEventListener('touchend', onTouchEnd)\n      disableContextMenu()\n\n      if (callbacksRef.current.onStart) {\n        callbacksRef.current.onStart({ point, pointInWindow })\n      }\n    },\n    [onTouchEnd, onTouchMove]\n  )\n\n  const onTouchStart = React.useCallback(\n    (e: TouchEvent) => {\n      if (knobs?.length && !knobs.find((knob) => knob.contains(e.target as Node))) {\n        return\n      }\n\n      saveContainerPosition()\n\n      const pointInWindow = getTouchPoint(e.touches[0])\n      const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n\n      // we wait 120ms to start the gesture to be sure that the user\n      // is not trying to scroll the page\n      handleTouchStartTimerRef.current = window.setTimeout(\n        () => handleTouchStart(point, pointInWindow),\n        120\n      )\n    },\n    [handleTouchStart, saveContainerPosition, knobs]\n  )\n\n  const detectTouchDevice = React.useCallback(() => {\n    setTouchDevice(true)\n    document.removeEventListener('touchstart', detectTouchDevice)\n  }, [])\n\n  // if the user is scrolling on mobile, we cancel the drag gesture\n  const touchScrollListener = React.useCallback(() => {\n    cancelTouchStart()\n  }, [])\n\n  React.useLayoutEffect(() => {\n    if (isTouchDevice) {\n      const container = containerRef.current\n      container?.addEventListener('touchstart', onTouchStart, { capture: true, passive: false })\n      // we are adding this touchmove listener to cancel drag if user is scrolling\n      // however, it's also important to have a touchmove listener always set\n      // with non-capture and non-passive option to prevent an issue on Safari\n      // with e.preventDefault (https://github.com/atlassian/react-beautiful-dnd/issues/1374)\n      document.addEventListener('touchmove', touchScrollListener, {\n        capture: false,\n        passive: false,\n      })\n      document.addEventListener('touchend', touchScrollListener, {\n        capture: false,\n        passive: false,\n      })\n\n      return () => {\n        container?.removeEventListener('touchstart', onTouchStart)\n        document.removeEventListener('touchmove', touchScrollListener)\n        document.removeEventListener('touchend', touchScrollListener)\n        document.removeEventListener('touchmove', onTouchMove)\n        document.removeEventListener('touchend', onTouchEnd)\n        enableContextMenu()\n        cancelTouchStart()\n      }\n    }\n    // if non-touch device\n    document.addEventListener('touchstart', detectTouchDevice)\n    return () => {\n      document.removeEventListener('touchstart', detectTouchDevice)\n      document.removeEventListener('mousemove', onMouseMove)\n      document.removeEventListener('mouseup', onMouseUp)\n    }\n  }, [\n    isTouchDevice,\n    detectTouchDevice,\n    onMouseMove,\n    onTouchMove,\n    touchScrollListener,\n    onTouchEnd,\n    onMouseUp,\n    containerRef,\n    onTouchStart,\n  ])\n\n  // on touch devices, we cannot attach the onTouchStart directly via React:\n  // Touch handlers must be added with {passive: false} to be cancelable.\n  // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n  return isTouchDevice ? {} : { onMouseDown }\n}\n","import React, { HTMLAttributes } from 'react'\n\nimport { findItemIndexAtPosition } from './helpers'\nimport { useDrag } from './hooks'\nimport { Point } from './types'\n\nconst arrayMoveMutate = <A,>(array: A[], from: number, to:number) => {\n\tconst startIndex = from < 0 ? array.length + from : from;\n\n\tif (startIndex >= 0 && startIndex < array.length) {\n\t\tconst endIndex = to < 0 ? array.length + to : to;\n\n\t\tconst [item] = array.splice(from, 1);\n\t\tarray.splice(endIndex, 0, item);\n\t}\n};\n\nconst arrayMove = <A,>(array: A[], from: number, to: number) => {\n\tarray = array.slice();\n\tarrayMoveMutate(array, from, to);\n\treturn array;\n};\n\nconst DEFAULT_CONTAINER_TAG = 'div'\n\ntype Props<TTag extends keyof JSX.IntrinsicElements> = HTMLAttributes<TTag> & {\n  children: React.ReactNode\n  /** Determines whether drag functionality is enabled, defaults to true */\n  allowDrag?: boolean\n  /** Called when the user finishes a sorting gesture. */\n  onSortEnd: (oldIndex: number, newIndex: number) => void\n  /** Class applied to the item being dragged */\n  draggedItemClassName?: string\n  /** Determines which type of html tag will be used for a container element */\n  as?: TTag\n}\n\n// this context is only used so that SortableItems can register/remove themselves\n// from the items list\ntype Context = {\n  registerItem: (item: HTMLElement) => void\n  removeItem: (item: HTMLElement) => void\n  registerKnob:  (item: HTMLElement) => void\n  removeKnob:  (item: HTMLElement) => void\n}\n\nconst SortableListContext = React.createContext<Context | undefined>(undefined)\nconst SortableList = <TTag extends keyof JSX.IntrinsicElements = typeof DEFAULT_CONTAINER_TAG>({ children, allowDrag = true, onSortEnd, draggedItemClassName, as, ...rest }: Props<TTag>) => {\n  // this array contains the elements than can be sorted (wrapped inside SortableItem)\n  const itemsRef = React.useRef<HTMLElement[]>([])\n  // this array contains the coordinates of each sortable element (only computed on dragStart and used in dragMove for perf reason)\n  const itemsRect = React.useRef<DOMRect[]>([])\n  // Hold all registered knobs\n  const knobs = React.useRef<HTMLElement[]>([]);\n  // contains the container element\n  const containerRef = React.useRef<HTMLElement | null>(null)\n  // contains the target element (copy of the source element)\n  const targetRef = React.useRef<HTMLElement | null>(null)\n  // contains the index in the itemsRef array of the element being dragged\n  const sourceIndexRef = React.useRef<number | undefined>(undefined)\n  // contains the index in the itemsRef of the element to be exchanged with the source item\n  const lastTargetIndexRef = React.useRef<number | undefined>(undefined)\n  // contains the offset point where the initial drag occurred to be used when dragging the item\n  const offsetPointRef = React.useRef<Point>({ x: 0, y: 0 })\n\n  React.useEffect(() => {\n    return () => {\n      // cleanup the target element from the DOM when SortableList in unmounted\n      if (targetRef.current) {\n        document.body.removeChild(targetRef.current)\n      }\n    }\n  }, [])\n\n  const updateTargetPosition = (position: Point) => {\n    if (targetRef.current) {\n      const offset = offsetPointRef.current\n\n      // we use `translate3d` to force using the GPU if available\n      targetRef.current.style.transform = `translate3d(${position.x - offset.x}px, ${\n        position.y - offset.y\n      }px, 0px)`\n    }\n  }\n\n  const copyItem = React.useCallback(\n    (sourceIndex: number) => {\n      if (!containerRef.current) {\n        return\n      }\n\n      const source = itemsRef.current[sourceIndex]\n      const sourceRect = itemsRect.current[sourceIndex]\n\n      const copy = source.cloneNode(true) as HTMLElement\n\n      // added the \"dragged\" class name\n      if (draggedItemClassName) {\n        draggedItemClassName.split(' ').forEach((c) => copy.classList.add(c))\n      }\n\n      // we ensure the copy has the same size than the source element\n      copy.style.width = `${sourceRect.width}px`\n      copy.style.height = `${sourceRect.height}px`\n      // we place the target starting position to the top left of the window\n      // it will then be moved relatively using `transform: translate3d()`\n      copy.style.position = 'fixed'\n      copy.style.margin = '0'\n      copy.style.top = '0'\n      copy.style.left = '0'\n\n      document.body.appendChild(copy)\n\n      targetRef.current = copy\n    },\n    [draggedItemClassName]\n  )\n\n  const listeners = useDrag({\n    containerRef,\n    knobs: knobs.current,\n    onStart: ({ pointInWindow }) => {\n      if (!containerRef.current) {\n        return\n      }\n\n      itemsRect.current = itemsRef.current.map((item) => item.getBoundingClientRect())\n\n      const sourceIndex = findItemIndexAtPosition(pointInWindow, itemsRect.current)\n      // if we are not starting the drag gesture on a SortableItem, we exit early\n      if (sourceIndex === -1) {\n        return\n      }\n\n      // saving the index of the item being dragged\n      sourceIndexRef.current = sourceIndex\n\n      // the item being dragged is copied to the document body and will be used as the target\n      copyItem(sourceIndex)\n\n      // hide source during the drag gesture\n      const source = itemsRef.current[sourceIndex]\n      source.style.opacity = '0'\n      source.style.visibility = 'hidden'\n\n      // get the offset between the source item's window position relative to the point in window\n      const sourceRect = source.getBoundingClientRect()\n      offsetPointRef.current = {\n        x: pointInWindow.x - sourceRect.left,\n        y: pointInWindow.y - sourceRect.top,\n      }\n\n      updateTargetPosition(pointInWindow)\n\n      // Adds a nice little physical feedback\n      if (window.navigator.vibrate) {\n        window.navigator.vibrate(100)\n      }\n    },\n    onMove: ({ pointInWindow }) => {\n      updateTargetPosition(pointInWindow)\n\n      const sourceIndex = sourceIndexRef.current\n      // if there is no source, we exit early (happened when drag gesture was started outside a SortableItem)\n      if (sourceIndex === undefined) {\n        return\n      }\n\n      const targetIndex = findItemIndexAtPosition(pointInWindow, itemsRect.current, {\n        fallbackToClosest: true,\n      })\n      // if not target detected, we don't need to update other items' position\n      if (targetIndex === -1) {\n        return\n      }\n      // we keep track of the last target index (to be passed to the onSortEnd callback)\n      lastTargetIndexRef.current = targetIndex\n\n      const isMovingRight = sourceIndex < targetIndex\n\n      // in this loop, we go over each sortable item and see if we need to update their position\n      for (let index = 0; index < itemsRef.current.length; index += 1) {\n        const currentItem = itemsRef.current[index]\n        const currentItemRect = itemsRect.current[index]\n        // if current index is between sourceIndex and targetIndex, we need to translate them\n        if (\n          (isMovingRight && index >= sourceIndex && index <= targetIndex) ||\n          (!isMovingRight && index >= targetIndex && index <= sourceIndex)\n        ) {\n          // we need to move the item to the previous or next item position\n          const nextItemRects = itemsRect.current[isMovingRight ? index - 1 : index + 1]\n          if (nextItemRects) {\n            const translateX = nextItemRects.left - currentItemRect.left\n            const translateY = nextItemRects.top - currentItemRect.top\n            // we use `translate3d` to force using the GPU if available\n            currentItem.style.transform = `translate3d(${translateX}px, ${translateY}px, 0px)`\n          }\n        }\n        // otherwise, the item should be at its original position\n        else {\n          currentItem.style.transform = 'translate3d(0,0,0)'\n        }\n        // we want the translation to be animated\n        currentItem.style.transitionDuration = '300ms'\n      }\n    },\n    onEnd: () => {\n      // we reset all items translations (the parent is expected to sort the items in the onSortEnd callback)\n      for (let index = 0; index < itemsRef.current.length; index += 1) {\n        const currentItem = itemsRef.current[index]\n        currentItem.style.transform = ''\n        currentItem.style.transitionDuration = ''\n      }\n\n      const sourceIndex = sourceIndexRef.current\n      if (sourceIndex !== undefined) {\n        // show the source item again\n        const source = itemsRef.current[sourceIndex]\n        if (source) {\n          source.style.opacity = '1'\n          source.style.visibility = ''\n        }\n\n        const targetIndex = lastTargetIndexRef.current\n        if (targetIndex !== undefined) {\n          if (sourceIndex !== targetIndex) {\n            // sort our internal items array\n            itemsRef.current = arrayMove(itemsRef.current, sourceIndex, targetIndex)\n            // let the parent know\n            onSortEnd(sourceIndex, targetIndex)\n          }\n        }\n      }\n      sourceIndexRef.current = undefined\n      lastTargetIndexRef.current = undefined\n\n      // cleanup the target element from the DOM\n      if (targetRef.current) {\n        document.body.removeChild(targetRef.current)\n        targetRef.current = null\n      }\n    },\n  })\n\n  const registerItem = React.useCallback((item: HTMLElement) => {\n    itemsRef.current.push(item)\n  }, [])\n\n  const removeItem = React.useCallback((item: HTMLElement) => {\n    const index = itemsRef.current.indexOf(item)\n    if (index !== -1) {\n      itemsRef.current.splice(index, 1)\n    }\n  }, [])\n\n  const registerKnob = React.useCallback((item: HTMLElement) => {\n    knobs.current.push(item)\n  }, [])\n\n  const removeKnob = React.useCallback((item: HTMLElement) => {\n    const index = knobs.current.indexOf(item)\n\n    if (index !== -1) {\n      knobs.current.splice(index, 1)\n    }\n  }, [])\n\n  // we need to memoize the context to avoid re-rendering every children of the context provider\n  // when not needed\n  const context = React.useMemo(() => ({ registerItem, removeItem, registerKnob, removeKnob }), [registerItem, removeItem, registerKnob, removeKnob])\n\n  return React.createElement(\n    as || DEFAULT_CONTAINER_TAG, \n    { \n      ...(allowDrag ? listeners : {}),\n      ...rest, \n      ref: containerRef\n    },\n    <SortableListContext.Provider value={context}>{children}</SortableListContext.Provider>\n  ) \n}\n\nexport default SortableList\n\ntype ItemProps = {\n  children: React.ReactElement\n}\n\n/**\n * SortableItem only adds a ref to its children so that we can register it to the main Sortable\n */\nexport const SortableItem = ({ children }: ItemProps) => {\n  const context = React.useContext(SortableListContext)\n  if (!context) {\n    throw new Error('SortableItem must be a child of SortableList')\n  }\n  const { registerItem, removeItem } = context\n  const elementRef = React.useRef<HTMLElement | null>(null)\n\n  React.useEffect(() => {\n    const currentItem = elementRef.current\n    if (currentItem) {\n      registerItem(currentItem)\n    }\n\n    return () => {\n      if (currentItem) {\n        removeItem(currentItem)\n      }\n    }\n    // if the children changes, we want to re-register the DOM node\n  }, [registerItem, removeItem, children])\n\n  return React.cloneElement(children, { ref: elementRef })\n}\n\nexport const SortableKnob = ({ children  }: ItemProps) => {\n  const context = React.useContext(SortableListContext)\n\n  if (!context) {\n    throw new Error('SortableKnob must be a child of SortableList')\n  }\n\n  const { registerKnob, removeKnob } = context;\n\n  const elementRef = React.useRef<HTMLElement | null>(null)\n\n  React.useEffect(() => {\n    const currentItem = elementRef.current\n\n    if (currentItem) {\n      registerKnob(currentItem)\n    }\n\n    return () => {\n      if (currentItem) {\n        removeKnob(currentItem)\n      }\n    }\n    // if the children changes, we want to re-register the DOM node\n  }, [registerKnob, removeKnob, children])\n\n  return React.cloneElement(children, { ref: elementRef })\n};\n"],"names":["findItemIndexAtPosition","_a","itemsRect","_b","x","y","_c","_d","fallbackToClosest","smallestDistance","smallestDistanceIndex","index","length","rect","left","right","top","bottom","itemCenterX","itemCenterY","distance","Math","sqrt","pow","getMousePoint","e","Number","clientX","clientY","getTouchPoint","touch","getPointInContainer","point","containerTopLeft","preventDefault","event","disableContextMenu","window","addEventListener","capture","passive","enableContextMenu","removeEventListener","useDrag","onStart","onMove","onEnd","containerRef","knobs","containerPositionRef","React","useRef","handleTouchStartTimerRef","undefined","isFirstMoveRef","callbacksRef","useState","isTouchDevice","setTouchDevice","useEffect","current","cancelTouchStart","clearTimeout","saveContainerPosition","useCallback","bounds","getBoundingClientRect","onDrag","pointInWindow","onMouseMove","onTouchMove","cancelable","touches","document","onMouseUp","onTouchEnd","onMouseDown","button","find","knob","contains","target","handleTouchStart","onTouchStart","setTimeout","detectTouchDevice","touchScrollListener","useLayoutEffect","container_1","arrayMoveMutate","array","from","to","startIndex","endIndex","item","splice","arrayMove","slice","DEFAULT_CONTAINER_TAG","SortableListContext","createContext","SortableList","children","allowDrag","onSortEnd","draggedItemClassName","as","rest","itemsRef","targetRef","sourceIndexRef","lastTargetIndexRef","offsetPointRef","body","removeChild","updateTargetPosition","position","offset","style","transform","copyItem","sourceIndex","source","sourceRect","copy","cloneNode","split","forEach","c","classList","add","width","height","margin","appendChild","listeners","map","opacity","visibility","navigator","vibrate","targetIndex","isMovingRight","currentItem","currentItemRect","nextItemRects","translateX","translateY","transitionDuration","registerItem","push","removeItem","indexOf","registerKnob","removeKnob","context","useMemo","createElement","ref","Provider","value","SortableItem","useContext","Error","elementRef","cloneElement","SortableKnob"],"mappings":"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"}